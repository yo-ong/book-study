## 1️⃣ 전역 공간에서의 `this`

### ✔ 기본 개념

- `this`는 **함수를 호출할 때** 결정된다.
- 실행 컨텍스트가 생성될 때 함께 결정된다.
- 전역 컨텍스트에서의 `this`는 **전역 객체**를 가리킨다.
    - 브라우저: `window`
    - Node.js: `global`

---

### ✔ 전역 변수와 전역 객체의 관계

전역에서 `var`로 선언한 변수는 전역 객체의 프로퍼티가 된다.

```tsx
var a = 1;
window.b = 2;

console.log(a, window.a, this.a);
// 1 1 1

console.log(b, window.b, this.b);
// 2 2 2
```

겉으로 보기에는 `var a = 1`과 `window.a = 1`이 동일해 보인다.

---

### ✔ delete 차이점

하지만 내부 속성에서 차이가 있다.

```tsx
var a = 1;
delete window.a;
console.log(a);
// 1 (삭제되지 않음)

window.c = 3;
delete window.c;
console.log(c);
// ReferenceError
```

### 🔎 이유

- `var`로 선언한 전역 변수는
    
    → 전역 객체의 프로퍼티가 되지만
    
    → `configurable: false`로 정의됨
    
- 직접 할당한 프로퍼티는
    
    → `configurable: true`
    
    → `delete` 가능
    

---

## 2️⃣ 함수 호출 vs 메서드 호출

### ✔ 차이 기준

구분 기준은 **호출 방식**이다.

- `객체.함수()` → 메서드 호출
- `함수()` → 함수 호출

---

### ✔ 예제

```tsx
var func = function (x) {
  console.log(this, x);
};

func(1);
// window, 1

var obj = {
  method: func
};

obj.method(2);
// obj 객체, 2
```

### 📌 정리

- 함수로 호출 → `this = 전역 객체`
- 메서드로 호출 → `this = 호출한 객체`

---

## 3️⃣ 메서드 내부에서의 `this`

```tsx
var obj = {
  methodA: function () {
    console.log(this);
  },
  inner: {
    methodB: function () {
      console.log(this);
    }
  }
};

obj.methodA();        // obj
obj.inner.methodB();  // inner 객체
```

👉 점(`.`) 앞의 객체가 `this`

---

## 4️⃣ 함수로 호출했을 때 내부 `this`

```tsx
function test() {
  console.log(this);
}

test();
// window (브라우저 기준)
```

함수 호출 시 `this`가 지정되지 않으면 전역 객체를 참조한다.

(단, strict mode에서는 `undefined`)

---

## 5️⃣ 메서드 내부의 일반 함수 (this 유실 문제)

```tsx
var obj = {
  outer: function () {
    console.log(this); // obj

    var innerFunc = function () {
      console.log(this); // window
    };

    innerFunc();

    var obj2 = {
      innerMethod: innerFunc
    };

    obj2.innerMethod(); // obj2
  }
};

obj.outer();
```

### 왜 이런 결과가 나올까?

- `innerFunc()` → 함수 호출 → 전역 객체
- `obj2.innerMethod()` → 메서드 호출 → obj2

---

## 6️⃣ this를 우회하는 방법 (ES5 방식)

```tsx
var obj = {
  outer: function () {
    var self = this;

    var innerFunc = function () {
      console.log(self);
    };

    innerFunc();
  }
};

obj.outer();
// obj
```

`self = this`로 상위 `this`를 저장

---

## 7️⃣ 화살표 함수 (ES6)

화살표 함수는 `this`를 바인딩하지 않는다.

상위 스코프의 `this`를 그대로 사용한다.

```tsx
var obj = {
  outer: function () {
    console.log(this); // obj

    var innerFunc = () => {
      console.log(this); // obj
    };

    innerFunc();
  }
};

obj.outer();
```

✔ `this`가 고정되지 않고

✔ 상위 실행 컨텍스트의 `this`를 사용한다.

---

## 8️⃣ 콜백 함수에서의 `this`

콜백은 기본적으로 함수 호출이므로

`this`는 전역 객체가 된다.

하지만 **제어권을 가진 함수가 this를 지정할 수 있다.**

예:

```tsx
document.body.addEventListener('click', function () {
  console.log(this);
  // 클릭된 DOM 요소
});
```

`addEventListener`는 콜백 내부 `this`를 이벤트가 발생한 요소로 설정한다.

---

## 9️⃣ 생성자 함수에서의 `this`

`new`와 함께 호출하면 생성자 함수가 된다.

```tsx
var Cat = function (name, age) {
  this.bark = '야옹';
  this.name = name;
  this.age = age;
};

var choco = new Cat('초코', 7);
var nabi = new Cat('나비', 5);

console.log(choco.name); // 초코
```

### 동작 과정

1. 빈 객체 생성
2. `this`가 그 객체를 가리킴
3. 프로퍼티 추가
4. 완성된 객체 반환

✔ 생성자 내부 `this` → 생성될 인스턴스

---

## 🔟 명시적으로 this 바인딩하기

### 1. call

```tsx
var func = function (a, b, c) {
  console.log(this, a, b, c);
};

func.call({ x: 1 }, 4, 5, 6);
// { x:1 } 4 5 6
```

즉시 실행하면서 `this` 지정

---

### 2. apply

```tsx
func.apply({ x: 1 }, [4, 5, 6]);
```

차이점:

- `call` → 인자를 개별 전달
- `apply` → 배열로 전달

---

### 3. bind

```tsx
var boundFunc = func.bind({ x: 1 }, 10);

boundFunc(20, 30);
// { x:1 } 10 20 30
```

- 즉시 실행하지 않음
- 새로운 함수 반환
- `name` 프로퍼티에 `"bound "` 접두어가 붙는다

---

## 🔎 추가: 배열 메서드의 thisArg

```tsx
var obj = { value: 10 };

[1, 2, 3].forEach(function (num) {
  console.log(this.value + num);
}, obj);
```

두 번째 인자로 `this` 지정 가능

---

# 📌 최종 정리

### 🔹 기본 규칙 (명시적 바인딩이 없을 때)

- 전역에서의 `this` → 전역 객체
- 메서드 호출 → 호출한 객체
- 함수 호출 → 전역 객체
- 콜백 → 제어권을 가진 함수에 따름
- 생성자 함수 → 생성될 인스턴스

### 🔹 명시적 바인딩

- `call`, `apply` → 즉시 실행 + this 지정
- `bind` → 새로운 함수 반환
- 일부 메서드 → `thisArg` 제공