## 1. 메서드 오버라이드 (Method Override)

이미 상위 프로토타입에 정의된 메서드를 **인스턴스 또는 하위 프로토타입에서 같은 이름으로 다시 정의하는 것**을 말한다.

```jsx
var Person = function (name) {
  this.name = name;
};

Person.prototype.getName = function () {
  return this.name;
};

var iu = new Person('지금');

// 인스턴스에서 메서드 오버라이드
iu.getName = function () {
  return '바로 ' + this.name;
};

console.log(iu.getName()); // '바로 지금'
```

### 동작 원리

1. `iu.getName()`을 호출하면
2. 먼저 **iu 객체 자신**에게 `getName`이 있는지 확인
3. 있으면 그것을 사용하고, 없으면
4. `iu.__proto__`(= `Person.prototype`)에서 찾는다.

즉, **가까운 곳(자기 자신)부터 찾는다**는 것이 핵심이다.

이 탐색 과정이 바로 프로토타입 체이닝이다.

---

## 2. 프로토타입 체인 (Prototype Chain)

자바스크립트에서 객체는 자신의 프로퍼티에 원하는 값이 없으면

`__proto__`를 따라 상위 프로토타입에서 찾는다.

### 배열 예시

```jsx
const b = [1, 2];

b.__proto__ === Array.prototype;                  // true
b.__proto__.__proto__ === Object.prototype;       // true
Array.prototype.__proto__ === Object.prototype;   // true

// 생성자 관점
Array.__proto__ === Function.prototype;           // true
Function.prototype.__proto__ === Object.prototype; // true
```

### 구조 정리

- 배열 인스턴스 → `Array.prototype`
- `Array.prototype` → `Object.prototype`
- `Object.prototype` → `null` (최종 종점)

모든 객체는 결국 `Object.prototype`에 도달한다.

---

## 3. 데이터 타입별 프로토타입 구조

### Number

```jsx
const num = 345;

num.__proto__ === Number.prototype;               // true
Number.prototype.__proto__ === Object.prototype;  // true
```

### String

```jsx
const str = 'abc';

str.__proto__ === String.prototype;               // true
String.prototype.__proto__ === Object.prototype;  // true
```

### Boolean

```jsx
const bool = true;

bool.__proto__ === Boolean.prototype;             // true
Boolean.prototype.__proto__ === Object.prototype; // true
```

### 핵심 포인트

- 원시값도 메서드를 사용할 수 있는 이유는
- 자바스크립트 엔진이 **임시 래퍼 객체(Wrapper Object)**로 감싸기 때문이다.
- 그리고 그 객체의 프로토타입 체인을 통해 메서드를 사용한다.

---

## 4. 객체 전용 메서드의 예외사항

### 1) 모든 프로토타입의 최상단은 Object.prototype

어떤 생성자 함수든 `prototype`은 객체이므로

결국 최상단에는 `Object.prototype`이 존재한다.

### 2) 왜 객체 전용 메서드를 Object.prototype에 넣지 않을까?

만약 `Object.prototype`에 메서드를 추가하면:

- 배열
- 함수
- 숫자
- 문자열
- 불리언

모두 그 메서드를 사용할 수 있게 된다.

이는 **전역 오염(Prototype Pollution)** 문제를 일으킬 수 있다.

그래서 객체 전용 기능은 보통:

- `Object.keys`
- `Object.values`
- `Object.assign`

처럼 **Object 생성자 함수에 정적(static) 메서드로 정의**되어 있다.

---

### 3) Object.create(null)의 특징

```jsx
const obj = Object.create(null);
```

이 방식으로 생성한 객체는:

- `Object.prototype`을 상속받지 않는다.
- 즉, `__proto__`가 없다.
- `toString`, `hasOwnProperty` 같은 메서드도 없다.

### 장점

- 불필요한 내장 메서드가 없어 더 가볍다.
- 순수한 “딕셔너리 객체”로 사용하기 좋다.
- 키 충돌 위험이 줄어든다.

---

## 5. 다중 프로토타입 체인

기본 내장 객체는 보통 1~2단계로 끝나지만,

사용자가 직접 구성하면 더 긴 체인을 만들 수 있다.

```jsx
var Grade = function () {
  var args = Array.prototype.slice.call(arguments);
  for (var i = 0; i < args.length; i++) {
    this[i] = args[i];
  }
  this.length = args.length;
};

var g = new Grade(100, 80);

// 기본 상태
Grade.prototype.__proto__ === Object.prototype; // true

// 프로토타입 변경
Grade.prototype = [];

Grade.prototype.__proto__ === Array.prototype;  // true
```

이렇게 하면:

```
g → Grade.prototype(배열) → Array.prototype → Object.prototype → null
```

처럼 3단계 이상의 체인을 만들 수 있다.

즉, 프로토타입 체인은 **반드시 2단계로 제한되지 않는다.**

---

# 전체 정리

1. 생성자 함수를 `new`와 함께 호출하면 인스턴스가 생성된다.
2. 이 인스턴스는 자동으로 `constructor.prototype`을 참조한다.
3. 우리가 흔히 보는 `__proto__`는 그 내부 참조에 접근하는 접근자이다.
4. 프로퍼티를 찾을 때:
    - 자기 자신
    - `__proto__`
    - 그 위의 `__proto__`
    - …
    - 최종적으로 `Object.prototype`
    - 그 다음은 `null`
5. 이 탐색 과정을 **프로토타입 체이닝**이라고 한다.
6. 프로토타입 체인은 2단계로 고정된 구조가 아니라, 필요에 따라 얼마든지 확장 가능하다.
7. `Object.prototype`에는 모든 타입이 공유해도 되는 범용 메서드만 존재한다.
8. 객체 전용 기능은 `Object` 생성자에 정적 메서드로 정의된다.