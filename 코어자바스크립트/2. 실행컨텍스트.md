# 1️⃣ 실행 컨텍스트란?

실행할 코드에 필요한 **환경 정보들을 담은 객체**

엔진이 내부적으로 생성하며 개발자가 직접 접근할 수는 없다.

---

## 실행 컨텍스트가 생성되는 경우

1. 전역 코드 실행 시 → 전역 실행 컨텍스트 생성
2. 함수 호출 시 → 함수 실행 컨텍스트 생성
3. eval 실행 시 (거의 사용 안 함)

---

## 실행 컨텍스트는 스택 구조

```
Call Stack
-----------------
|   함수2        |
|   함수1        |
|   전역         |
-----------------
```

- 가장 위에 있는 컨텍스트가 현재 실행 중
- 함수 종료 시 pop

---

# 2️⃣ 실행 컨텍스트 생성 과정 (중요 🔥)

실행 컨텍스트는 2단계로 진행된다.

## 1단계: 생성 단계 (Creation Phase)

아직 코드 실행 전

이 단계에서 수집하는 것:

1. variableEnvironment
2. lexicalEnvironment
3. thisBinding

이때 **호이스팅이 발생**

---

## 2단계: 실행 단계 (Execution Phase)

- 코드 한 줄씩 실행
- 변수에 값 할당
- 함수 호출
- lexicalEnvironment 갱신

---

# 3️⃣ variableEnvironment vs lexicalEnvironment

실행 컨텍스트 생성 시:

```
variableEnvironment → 복사 → lexicalEnvironment
```

초기에는 동일하다.

하지만 차이점:

| 구분 | 특징 |
| --- | --- |
| variableEnvironment | 초기 상태 유지 |
| lexicalEnvironment | 실행 중 변경사항 반영 |

**실무적으로는 거의 lexicalEnvironment 개념만 이해해도 충분하다.**

---

# 4️⃣ lexicalEnvironment 구조

lexicalEnvironment는 두 가지로 구성된다.

1. environmentRecord
2. outerEnvironmentReference

---

# 5️⃣ environmentRecord (호이스팅의 실체)

현재 컨텍스트 내부의 식별자 정보를 저장한다.

저장 대상:

- 변수 선언 (var, let, const)
- 함수 선언
- 매개변수
- arguments 객체

---

## 🔥 호이스팅의 정확한 의미

코드가 위로 끌어올려지는 게 아니다.

**실행 전에 식별자 정보를 먼저 수집하는 과정**을 우리가 호이스팅이라고 부른다.

---

## var 호이스팅

```jsx
console.log(a);
var a = 1;
```

엔진 해석:

```jsx
var a;
console.log(a);
a = 1;
```

출력:

```
undefined
```

---

## 함수 선언식 호이스팅

함수 선언은 **전체가 올라간다**

```jsx
console.log(a);
function a() {}
```

해석:

```jsx
function a() {}
console.log(a);
```

출력: 함수

---

## 함수 선언식 vs 변수 선언 우선순위

함수 선언이 변수 선언보다 우선

```jsx
console.log(a);
var a = 1;
function a() {}
```

해석:

```jsx
function a() {}
var a;
console.log(a);
a = 1;
```

출력: 함수

---

# 6️⃣ let, const는 왜 다를까? (누락된 부분 🔥)

let, const도 호이스팅 된다.

하지만

**초기화 이전에는 접근 불가**

이를 TDZ(Temporal Dead Zone)라고 한다.

```jsx
console.log(a);
let a = 1;
```

→ ReferenceError

왜?

- 식별자는 수집됨
- 하지만 초기화되지 않음

---

# 7️⃣ outerEnvironmentReference (스코프 체인)

현재 함수가 **선언될 당시의 lexicalEnvironment를 참조**

이게 핵심이다.

"호출 시점"이 아니라

"선언 시점" 기준이다.

---

## 스코프 체인 동작 방식

변수 접근 시:

1. 현재 environmentRecord에서 찾음
2. 없으면 outerEnvironmentReference로 이동
3. 계속 반복
4. 전역까지 가도 없으면 ReferenceError

---

## 예제 해석

```jsx
var a = 1;

function outer() {
  var b = 2;

  function inner() {
    console.log(b);
  }

  inner();
}

outer();
```

inner의 outerEnvironmentReference는

outer의 lexicalEnvironment를 가리킨다.

그래서 b 접근 가능.

---

# 8️⃣ 클로저와의 연결 (중요 🔥)

함수가 종료되어도

그 함수의 lexicalEnvironment를

누군가 참조하고 있으면

메모리에서 사라지지 않는다.

```jsx
function outer() {
  var a = 1;

  return function inner() {
    console.log(a);
  };
}

var fn = outer();
fn();
```

outer는 끝났지만

inner가 a를 참조하고 있으므로

a는 살아있다.

이게 클로저의 본질이다.

---

# 9️⃣ thisBinding

실행 컨텍스트 생성 시 결정된다.

규칙 요약:

1. 일반 함수 호출 → 전역 객체 (strict mode면 undefined)
2. 메서드 호출 → 호출한 객체
3. 생성자 호출(new) → 새 객체
4. 화살표 함수 → 상위 스코프의 this 그대로 사용

this는 **lexicalEnvironment에 저장되지 않는다**

별도의 thisBinding 슬롯에 저장된다.

---

# 🔟 함수 선언식의 위험성 정리

같은 이름의 함수 선언이 여러 개 있으면

가장 마지막 선언이 최종 적용된다.

파일이 커질수록 예측 어려움.

그래서 실무에서는:

- 함수 표현식
- const + 함수
- 화살표 함수

를 선호한다.

---

# 📌 전체 구조 한 번에 정리

## 실행 컨텍스트는 활성화 시

1. variableEnvironment 생성
2. lexicalEnvironment 생성
    - environmentRecord
    - outerEnvironmentReference
3. thisBinding 결정

---

## 호이스팅은

environmentRecord가

실행 전에 식별자를 수집하는 과정

---

## 스코프 체인은

outerEnvironmentReference를 따라

식별자를 검색하는 과정

---

# 🎯 최종 요약

- 실행 컨텍스트는 코드 실행에 필요한 환경 객체
- 스택 구조로 관리됨
- 생성 단계에서 식별자 수집 (호이스팅)
- lexicalEnvironment가 실제 스코프 역할
- outerEnvironmentReference가 스코프 체인을 만든다
- 함수는 선언 시점의 환경을 기억한다 (클로저)
- this는 별도로 바인딩된다
- let/const는 TDZ 존재