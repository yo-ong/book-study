## 🧠 자바스크립트는 프로토타입 기반 언어

자바스크립트는 **프로토타입 기반(prototype-based)** 언어이다.

- 클래스 기반 언어 → `class`를 통한 상속
- 프로토타입 기반 언어 → **기존 객체를 원형으로 복제**하여 확장

즉, 다른 객체를 참조하여 기능을 공유하는 방식으로 상속과 유사한 효과를 만든다.

---

# 1️⃣ 프로토타입의 개념 이해

---

## 1.1 constructor, prototype, instance

### 🔹 기본 개념

1. 생성자 함수를 `new`와 함께 호출하면 **인스턴스(instance)** 가 생성된다.
2. 생성된 인스턴스에는 자동으로 `__proto__` 프로퍼티가 생성된다.
3. 이 `__proto__`는 생성자 함수의 `prototype`을 참조한다.

### 🔹 구조 정리

```
instance
   ↓ (__proto__)
constructor.prototype
```

✔️ 즉,

> new로 생성된 인스턴스의 `__proto__`는 생성자 함수의 `prototype`을 참조한다.
> 

---

### 🔹 실무에서의 권장 방법

`__proto__`는 내부 슬롯에 접근하는 방식이므로 실무에서는 아래 메서드를 사용한다.

- `Object.getPrototypeOf(obj)`
- `Object.create(proto)`

---

## 🔎 예제 코드 분석

```tsx
var Person = function (name){
  this._name = name;
};

Person.prototype.getName = function() {
  return this._name;
};

var suzi = new Person('Suzi');

suzi.__proto__.getName(); // undefined

suzi.__proto__.name = 'SUZI__proto__';
suzi.__proto__.getName(); // 'SUZI__proto__'

suzi.getName(); // 'Suzi'
```

### 🔹 왜 undefined가 나올까?

핵심은 **this의 바인딩 대상**이다.

- `suzi.__proto__.getName()` 호출 시
    - this → `suzi.__proto__`
    - `_name`이 없음 → `undefined`
- `suzi.getName()` 호출 시
    - this → `suzi`
    - `_name` 존재 → `'Suzi'`

👉 메서드가 어디에 정의되어 있는지가 아니라

👉 **어떤 객체가 호출했는지가 중요하다**

---

## 🔎 콘솔에서 프로토타입 확인

```tsx
var arr = [1,2];
console.dir(arr);
console.dir(Array);
```

![Image](https://developer.chrome.com/static/docs/devtools/console/api/image/the-result-the-consolet-deafe365f75ef.png)

![Image](https://i.sstatic.net/8Bqob.png)

![Image](https://developer.mozilla.org/en-US/docs/Web/API/console/dir_static/console-dir.png)

[Image](https://cdn-media-1.freecodecamp.org/images/ZNgTtP4W2av-lJDUoRDdf7DmuWtnGumvbFUe)

### 🔹 확인 포인트

- 배열 인스턴스의 `__proto__` → `Array.prototype`
- `Array` 함수 자체에도 `prototype` 존재
- 결국 모든 객체는 프로토타입 체인을 통해 연결된다.

---

# 1.2 constructor 프로퍼티

### 🔹 constructor란?

- 생성자 함수의 `prototype` 객체 내부에는 `constructor` 프로퍼티가 존재한다.
- 인스턴스의 `__proto__` 내부에도 동일하게 존재한다.

즉, 다음이 모두 가능하다.

---

## 🔎 예제 정리

```tsx
var Person = function(name) {
  this.name = name;
};

var p1 = new Person('사람1');
var p1Proto = Object.getPrototypeOf(p1);

var p2 = new Person.prototype.constructor('사람2');
var p3 = new p1Proto.constructor('사람3');
var p4 = new p1.__proto__.constructor('사람4');
var p5 = new p1.constructor('사람5');
```

### 🔹 모두 동일한 생성자를 가리킨다

아래는 전부 같은 constructor를 참조한다.

```
[Constructor]
[instance].__proto__.constructor
[instance].constructor
Object.getPrototypeOf(instance).constructor
[Constructor].prototype.constructor
```

✔️ 결국 모두 `Person`을 가리킨다.

---

## 📌 핵심 요약

### 1️⃣ 인스턴스 생성 시

- `new`로 생성하면
- 인스턴스의 `__proto__`
- → 생성자 함수의 `prototype`을 참조

---

### 2️⃣ 메서드 실행 시

- this는 **호출한 객체**
- 프로토타입에 정의된 메서드라도
- 호출 주체가 무엇인지가 가장 중요

---

### 3️⃣ constructor 프로퍼티

- prototype 내부에 존재
- 인스턴스를 통해서도 접근 가능
- 결국 원래 생성자를 추적할 수 있음

---

## 🎯 한 줄 정리

> new로 생성된 인스턴스는 생성자의 prototype을 참조하며,
> 
> 
> 모든 객체는 이 프로토타입 연결 구조를 통해 동작한다.
>