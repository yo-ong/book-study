# 클래스

자바스크립트는 **프로토타입 기반 언어**다. 전통적인 의미의 클래스(설계도 → 인스턴스 생성 구조)를 기본 개념으로 갖는 언어는 아니다.

하지만 생성자 함수와 프로토타입 체이닝을 활용하면 클래스처럼 동작하도록 만들 수 있고, ES6 이후에는 이를 더 직관적으로 표현할 수 있는 `class` 문법이 도입되었다. 다만 내부 동작 원리는 여전히 프로토타입 기반이다.

---

## 생성자 함수와 프로토타입

예를 들어 `Array` 생성자 함수를 `new`와 함께 호출하면 인스턴스가 생성된다.

- `Array` → 생성자 함수 (클래스처럼 보이는 역할)
- `Array.prototype` → 인스턴스들이 공유하는 메서드 집합
- 인스턴스 → 내부 `[[Prototype]]`이 `Array.prototype`을 참조

엄밀히 말하면 “상속”이 아니라 **프로토타입 체이닝에 의한 위임(delegate)** 이다.

인스턴스 메서드라는 표현보다는 **프로토타입 메서드**라는 표현이 더 정확하다.

---

## 클래스 상속 (프로토타입 기반 구현)

### 문제 코드 분석

```jsx
var Grade = function () {
  var args = Array.prototype.slice.call(arguments);
  for (var i = 0; i < args.length; i++) {
    this[i] = args[i];
  }
  this.length = args.length;
};
Grade.prototype = [];
var g = new Grade(100, 80);

g.push(90);
console.log(g.length);
delete g.length;
g.push(70);
console.log(g);
```

### 동작 과정

1. `Grade.prototype = []`
    - `Grade`의 프로토타입을 배열 인스턴스로 교체
    - 따라서 `push` 같은 배열 메서드를 사용할 수 있음
2. `g.push(90)`
    - `push`는 `length`를 증가시킴
    - 현재 `g.length`는 인스턴스 자신의 프로퍼티
3. `delete g.length`
    - 인스턴스의 `length` 삭제
    - 이제 프로토타입 체인을 따라 `Grade.prototype.length` 참조
    - 배열의 기본 `length`는 0
4. 다시 `push`
    - 프로토타입의 `length`를 기준으로 동작

### 문제점

- `Grade.prototype = []`로 덮어쓰면 기존 `constructor`가 사라짐
- 인스턴스와 프로토타입이 `length`를 공유하는 문제 발생
- 의도치 않은 상태 공유 가능성

---

## constructor 복구

프로토타입을 교체하면 `constructor`가 사라진다.

```jsx
Grade.prototype = Object.create(Array.prototype);
Grade.prototype.constructor = Grade;
```

이 방식이 더 안전하다.

- `Object.create(Array.prototype)` → 깨끗한 객체 생성
- `constructor`를 다시 연결

---

## Object.create

`Object.create(proto)`는 지정한 프로토타입을 갖는 새 객체를 생성한다.

```jsx
var obj = Object.create(Array.prototype);
```

- 명시적으로 상속 구조를 만들 수 있음
- 기존 객체를 공유하지 않음
- ES5에서 가장 권장되는 상속 구현 방식

---

## Object.freeze

객체를 불변으로 만들고 싶을 때 사용한다.

```jsx
Object.freeze(Grade.prototype);
```

- 프로퍼티 추가/삭제/수정 불가
- 클래스의 인터페이스를 고정할 때 유용
- 얕은 동결(shallow freeze)이라는 점에 주의

---

## 상위 클래스에 접근 수단 제공 (ES5 방식)

ES5에서는 super가 없기 때문에 명시적으로 호출해야 한다.

```jsx
function Rectangle(width, height) {
  this.width = width;
  this.height = height;
}

Rectangle.prototype.getArea = function () {
  return this.width * this.height;
};

function Square(width) {
  Rectangle.call(this, width, width); // 부모 생성자 호출
}

Square.prototype = Object.create(Rectangle.prototype);
Square.prototype.constructor = Square;

Square.prototype.getArea = function () {
  return Rectangle.prototype.getArea.call(this);
};
```

- 생성자 내부에서 `call`
- 메서드 오버라이딩 시 명시적으로 부모 메서드 호출

---

# ES5 클래스 vs ES6 클래스 문법 비교

### ES5 방식

```jsx
var ES5 = function(name){
  this.name = name;
};

ES5.staticMethod = function(){
  return this.name + ' staticMethod';
};

ES5.prototype.method = function () {
  return this.name + ' method';
};

var es5Instance = new ES5('es5');
```

특징

- 생성자 함수 기반
- static은 함수 객체에 직접 추가
- 메서드는 prototype에 추가

---

### ES6 방식

```jsx
class ES6 {
  constructor(name) {
    this.name = name;
  }

  static staticMethod() {
    return this.name + ' staticMethod';
  }

  method() {
    return this.name + ' method';
  }
}

var es6Instance = new ES6('es6');
```

특징

- 문법적으로 더 명확
- 클래스 내부에 메서드 선언
- prototype에 자동 등록
- strict mode 기본 적용
- 호이스팅은 되지만 TDZ 존재

중요한 점은 **문법적 설탕(syntactic sugar)** 이라는 것. 내부 동작은 여전히 프로토타입 기반이다.

---

# ES6 상속 방법

수정된 코드:

```jsx
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  constructor(width) {
    super(width, width);
  }

  getArea() {
    console.log('size is: ' + super.getArea());
  }
}
```

핵심 요소

- `extends` → 프로토타입 연결
- `super()` → 부모 생성자 호출
- `super.method()` → 부모 메서드 접근
- 자식 클래스에서 constructor를 정의하면 반드시 `super()` 호출 필요

---

# 클래스 사용 시 추가적으로 알아야 할 것

### 1. 클래스는 함수다

```jsx
typeof ES6 === 'function'; // true
```

### 2. new 없이 호출 불가

ES6 클래스는 반드시 `new`와 함께 사용해야 한다.

### 3. 메서드는 열거되지 않는다

```jsx
Object.keys(ES6.prototype); // []
```

클래스 메서드는 기본적으로 `enumerable: false`

### 4. private 필드 (#)

```jsx
class Person {
  #age = 0;

  getAge() {
    return this.#age;
  }
}
```

- 외부에서 접근 불가
- 진짜 private

---

# 정리

자바스크립트는 본질적으로 프로토타입 기반 언어다.

- ES5: 생성자 함수 + prototype 조작
- ES6: class 문법 도입
- 하지만 내부 동작은 동일 (프로토타입 체이닝)

상속 또한 전통적인 클래스 복제가 아니라 **위임 기반 상속**이다.