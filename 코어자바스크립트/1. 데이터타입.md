## 1️⃣ 데이터 타입

자바스크립트의 데이터 타입은 크게 ****원시 타입(기본형)****과 ****참조 타입(객체형)****으로 나뉜다.

### ✅ 1. 원시 타입 (Primitive Type)

- Number
- String
- Boolean
- null
- undefined
- Symbol
- BigInt (추가로 포함됨)

> 💡 자바스크립트의 숫자는 기본적으로 **64비트 부동소수점(IEEE 754)** 방식으로 저장된다.
> 

---

### ✅ 2. 참조 타입 (Reference Type)

- Object
    - Array
    - Function
    - Date
    - RegExp
    - Map, WeakMap
    - Set, WeakSet
    - 기타 모든 객체

> ⚠️ 자바스크립트에서 함수도 객체이다.
> 

---

## 2️⃣ 변수에 값이 할당되는 과정

자바스크립트의 메모리는 크게

- **변수 영역**
- **데이터 영역**

으로 나뉘어 관리된다고 이해하면 좋다.

---

### 예시

```jsx
var a;
a = 'abc';
```

### 동작 과정

1. 변수 영역에 빈 공간 확보
2. 해당 공간에 식별자 `a` 저장
3. 데이터 영역에 `'abc'` 저장
4. 변수 영역의 `a`에 데이터 영역 주소를 연결

---

### 🔎 왜 변수 영역에 값을 직접 저장하지 않을까?

1. **데이터 변환을 자유롭게 하기 위해**
2. **메모리를 효율적으로 관리하기 위해**

예를 들어:

```jsx
var a = 'abc';
a = 'abcdef';
```

만약 변수 영역에 값을 직접 저장한다면:

- 문자열 길이가 달라지면 메모리를 다시 확보해야 함
- 인접 데이터들을 이동해야 할 수도 있음

→ 그래서 **변수에는 값이 아닌 주소를 저장**하는 구조를 사용한다.

---

# 3️⃣ 기본형과 참조형의 차이

## 🔹 공통점

대입 연산 시 **둘 다 복사**된다.

하지만 복사되는 내용이 다르다.

---

## 🔹 기본형 복사

```jsx
var a = 5;
var b = a;
```

- a가 가리키는 **값(주소)**이 복사됨
- b는 5를 가리키는 새로운 참조를 가짐
- 이후 a를 변경해도 b는 영향 없음

👉 값 자체가 복사되는 개념

---

## 🔹 참조형 복사

```jsx
var obj1 = { a: 1 };
var obj2 = obj1;
```

- 객체가 저장된 **주소 값**이 복사됨
- obj1과 obj2는 같은 객체를 참조

```jsx
obj2.a = 2;
```

→ obj1.a 도 2가 된다.

👉 **객체를 가리키는 주소가 복사되는 것**

---

# 4️⃣ 불변성과 가변성

## 🔹 불변성 (Immutable)

원시 타입은 모두 불변값이다.

```jsx
var a = 5;
a = 10;
```

5가 10으로 바뀐 것이 아니라,

- 10이라는 새로운 값이 데이터 영역에 생성
- a가 그 주소를 새로 참조

👉 기존 5는 변하지 않는다.

---

### 문자열도 불변이다

```jsx
var str = "abc";
str += "d";
```

- 기존 "abc"가 변한 것이 아니라
- "abcd"라는 새로운 문자열이 생성됨

---

## 🔹 가변성 (Mutable)

참조형은 가변성을 가진다.

```jsx
var obj = {
  a: 1,
  b: 'bbb'
};

obj.a = 2;
```

- obj가 참조하는 객체 자체는 유지됨
- 내부 프로퍼티 값이 변경됨

👉 객체 내부 상태는 변경 가능

---

# 5️⃣ 깊은 복사와 얕은 복사 (보완)

## 🔹 얕은 복사 (Shallow Copy)

객체의 **1단계까지만 복사**한다.

```jsx
var obj1 = { a: 1, b: { c: 2 } };
var obj2 = { ...obj1 };

obj2.b.c = 3;
```

👉 obj1.b.c도 3이 된다.

왜냐하면 `b`는 여전히 같은 객체를 참조하기 때문.

---

## 🔹 깊은 복사 (Deep Copy)

객체 내부의 객체까지 모두 새롭게 복사

### 방법 1: JSON 방식

```jsx
var obj2 = JSON.parse(JSON.stringify(obj1));
```

⚠️ 단점:

- 함수 복사 안됨
- undefined 사라짐
- Symbol 사라짐
- 순환참조 에러

---

### 방법 2: structuredClone (권장)

```jsx
var obj2 = structuredClone(obj1);
```

- 대부분의 경우 안전
- 최신 브라우저/Node에서 지원

---

# 6️⃣ null 과 undefined

## 🔹 undefined

- 값이 **할당되지 않은 상태**
- 자바스크립트 엔진이 자동 부여

```jsx
var a;
console.log(a); // undefined
```

---

## 🔹 null

- 개발자가 **의도적으로 비어있음을 표현**
- 명시적으로 넣는 값

```jsx
var a = null;
```

---

## 🔥 중요한 사실

```jsx
typeof null // "object"
```

👉 자바스크립트의 오래된 설계 오류

→ 실제로 null은 객체가 아님

---

# 7️⃣ 상수와 변수

```jsx
const a = 1;
```

- 재할당 불가능 → 상수

```jsx
const obj = { a: 1 };
obj.a = 2; // 가능
```

- 객체 내부 변경은 가능
- 단, 객체 자체 재할당은 불가

---

# 8️⃣ 핵심 개념 한 번에 정리

| 구분 | 기본형 | 참조형 |
| --- | --- | --- |
| 저장 방식 | 값의 주소 저장 | 객체의 주소 저장 |
| 복사 방식 | 값 복사 | 주소 복사 |
| 불변성 | 불변 | 가변 |
| 비교 방식 | 값 비교 | 참조 비교 |
| 예시 | Number, String 등 | Object, Array 등 |

---

# 9️⃣ 정리하면서 보완된 핵심 포인트

✔ BigInt도 원시 타입이다

✔ 함수도 객체이다

✔ 문자열은 불변이다

✔ 얕은 복사와 깊은 복사의 차이

✔ structuredClone이 최신 방식

✔ typeof null === "object"는 설계 버그

✔ const는 재할당만 막는다